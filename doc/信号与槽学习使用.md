## 信号槽介绍

### Qt信号槽

示例：

```c++
class Button : public QObject{
    Q_OBJECT
public:
    Button(QObject* parent = Q_NULLPTR) :QObject(parent) {};
signals:
    void PressDown();
};

class Lable : public QObject{
    Q_OBJECT
public:
    Lable(QObject* parent = Q_NULLPTR) :QObject(parent) {};
public slots:
    void OnPressDown() {qDebug() << "press down";};
};

auto *btn = new Button;
auto *lab = new Lable;    
QObject::connect(btn, &Button::PressDown, lab, &Lable::OnPressDown);
emit btn->PressDown();

```

1.通过connect信号和槽就进行了绑定，调用信号PressDown()，就会触发槽函数Lable::OnPressDown。

通过接口来实现同样功能：

```c++
class IEvent {
public:
   virtual  void OnPressDown() = 0;
};

class Button{
public:
    void SetIEvent(IEvent* event) { event_ = event;}
    void PressDown() { 
        if (event_) event_->OnPressDown();
    };
private:
    IEvent* event_ = nullptr;
};

class Lable : public IEvent {
public:
    void OnPressDown() override { std::cout << "press down\n"; };
};

auto* btn = new Button;
auto* lab = new Lable;
btn->SetIEvent(lab);    
btn->PressDown();
```

对比：解耦，可扩展性

1.接口与调用接口的对象是分离的，需要单独提取接

- 一个信号可以连接多个不同的槽。

```c++
class LineEdit : public QObject{
    Q_OBJECT
public:
    LineEdit(QObject* parent = Q_NULLPTR) :QObject(parent) {};
public slots:
    void OnPrint() {qDebug() << "press down";};
};
auto *btn = new Button;
auto *lab1 = new Lable;
auto *lab2 = new Lable;   
auto *edit = new LineEdit; 
QObject::connect(btn, &Button::PressDown, lab1, &Lable::OnPressDown);
QObject::connect(btn, &Button::PressDown, lab2, &Lable::OnPressDown);
QObject::connect(btn, &Button::PressDown, edit, &LineEdit::OnPrint);
emit btn->PressDown();
```

接口的需要这样实现

```c++
class Lable : public IEvent {
public:
    void OnPressDown() override { std::cout << "press down\n"; };
};
class LineEdit : public IEvent {
public:
    void OnPrint(){qDebug() << "press down";};
    void OnPressDown() override { OnPrint(); };
};

class Button{
public:
void AddIEvent(IEvent* event) { event_.pushback(event);}
void PressDown() { 
for(auto item : events_){
  item->OnPressDown();
}
private:
    vector<*IEvent> events_ ;
};

auto *btn = new Button;
auto *lab1 = new Lable;
auto *lab2 = new Lable;   
auto *edit = new LineEdit; 
btn->AddIEvent(lab1);
btn->AddIEvent(lab2);
btn->AddIEvent(edit);

```

接口的实现必须一一对应，不能像信号槽一样能够自由组合。

或者基于Fuction函数对象这样实现

```C++
using Event = std::function<void()>;
class Lable {
public:
    void OnPressDown() override { std::cout << "press down\n"; };
};

class LineEdit {
public:
    void OnPrint(){qDebug() << "press down";};
};

class Button{
public:
AddEvent(const Event &evnet){events_.pushback(evnet)};
void PressDown() { 
for(auto item : events_){
  item();
}
private:
    vector<Event> events_ ;
}    

auto *lab1 = new Lable;
auto *lab2 = new Lable;   
auto *edit = new LineEdit;
auto *btn = new Button;
btn->AddIEvent(std::bind(&Lable::OnPressDown, lab1));
btn->AddIEvent(std::bind(&Lable::OnPressDown, lab1));
btn->AddIEvent(std::bind(&LineEdit::OnPrint, btn));
```

这种方式看上去能更好的模拟，但是每添加一个一类Event(int a,int b)都需要添加一个 AddEvent类型的方法。且需要添加一个新的vector<Event> events_。**不过相对于接口，这种方法，可以传递lamad表达式，对于使用者还是非常方便**



- 一个槽也可以被多个信号连接，

```C++
class IEvent1 {
public:
   virtual  void OnPressDown() = 0;
};
class Button1{
public:
    void PressDown() { 
        if (event1_) event_->OnPressDown();
    };
};
class IEvent2 {
public:
   virtual  void OnPressDown() = 0;
};
class Button2{
public:
    void PressDown() { 
        if (event2_) event2_->OnPressDown();
    };
};
class Lable1 : public IEvent1, public IEvent2{
public:
    void OnPressDown() override { std::cout << "press down1\n"; };
    void OnPressDown2() override { std::cout << "press down2\n"; };
};
class Lable2 : public IEvent2 {
public:
    void OnPressDown() override { lable1_->OnPressDown2(); };
private:
    Lable1 lable1_;
};
```

代码上看这样的逻辑信号与槽的实现代码看上去更加铮整洁

- 生命周期的管理，对象销毁时，自动断开链接。接口实现对象销毁时需要通知调用者,多线程的情况还要考虑线程安全。

```C++
auto* btn = new Button;
auto* lab = new Lable;
btn->SetIEvent(lab);    
btn->PressDown();
delete lab;
//通知调用对象
btn->SetIEvent(null);  
```

当然我么也可以通过weak_ptr来管理接口

```c++
class IEvent : enable_shared_from_this<IEvent>{
public:
   virtual  void OnPressDown() = 0;
};

class Button{
public:
    void SetIEvent(const weak_ptr<IEvent>&event) { event_ = event;}
    void PressDown() { 
        if (event = event_.lock()) 
            event->OnPressDown();
    };
private:
    weak_ptr<IEvent> event_;
};

class Lable : public IEvent {
public:
    void OnPressDown() override { std::cout << "press down\n"; };
};

auto* btn = new Button;
auto* lab = new Lable;
btn->SetIEvent(lab);    
btn->PressDown();
```



通过对比我们发现：

1.通过接口或者fanction编程是可以实现信号槽的基本功能。

2.信号槽的设计确实能更好的解耦，以及能够让代码表达的更加清晰。

3.信号槽的功能可以作为基础库，在内部模块之间使用，能起到更好的解耦作用。

4.对外接口是不能使用信号槽，除非大家都使用一套信号槽模块。



### webrtc信号槽的实现



## 信号槽实现

## 信号槽性能
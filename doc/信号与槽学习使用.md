## 信号槽介绍

### Qt信号槽

示例：

```c++
class Button : public QObject{
    Q_OBJECT
public:
    Button(QObject* parent = Q_NULLPTR) :QObject(parent) {};
signals:
    void PressDown();
};

class Lable : public QObject{
    Q_OBJECT
public:
    Lable(QObject* parent = Q_NULLPTR) :QObject(parent) {};
public slots:
    void OnPressDown() {qDebug() << "press down";};
};

auto *btn = new Button;
auto *lab = new Lable;    
QObject::connect(btn, &Button::PressDown, lab, &Lable::OnPressDown);
emit btn->PressDown();

```

1.通过connect信号和槽就进行了绑定，调用信号PressDown()，就会触发槽函数Lable::OnPressDown。



通过接口解耦来实现同样功能：

```c++
class IEvent {
public:
   virtual  void OnPressDown() = 0;
};

class Button{
public:
    void SetIEvent(IEvent* event) { event_ = event;}
    void PressDown() { 
        if (event_) event_->OnPressDown();
    };
private:
    IEvent* event_ = nullptr;
};

class Lable : public IEvent {
public:
    void OnPressDown() override { std::cout << "press down\n"; };
};

auto* btn = new Button;
auto* lab = new Lable;
btn->SetIEvent(lab);    
btn->PressDown();
```

对比：解耦，可扩展性

1.接口与调用接口的对象是分离的，需要单独提取接口，信号与发出信号的对象关系更加内聚。

2.信号槽有更加好的扩展性：

- 一个信号可以连接多个槽，接口的实现需要变成这样

```c++
public:
void PressDown() { 
for(auto item : events_){
  item->OnPressDown();
}
private:
    vector<*IEvent>* events_ ;
```

- 多个信号可以连接同一个槽

3.生命周期的管理，接口实现对象销毁时需要通知







## 信号槽解决问题

### webrtc信号槽的实现

## 信号槽实现

## 信号槽性能